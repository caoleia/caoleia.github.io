(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{410:function(a,s,t){"use strict";t.r(s);var l=t(42),n=Object(l.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("字节码.class文件需要加载到内存中，才可以实例化类。ClassLoader的作用就是提前加载.class文件到内存中。\n在加载类时，使用的是"),t("code",[a._v("双亲委派模型")]),a._v("。\n")]),a._v(" "),t("h1",{attrs:{id:"类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),t("p",[a._v("类加载是一个将.class字节码文件实例化成Class对象并进行相关初始化的过程。\n简单说，类加载器就是根据指定全限定名（包名+类名）将class文件加载到JVM内存，转为Class对象。")]),a._v(" "),t("p",[a._v("如果站在JVM的角度来看，只存在两种类加载器:")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。")])]),a._v(" "),t("li",[t("p",[a._v("其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：\n扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\\lib\\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。\n应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。")])])]),a._v(" "),t("p",[a._v("类加载器类似于原始部落结构，最高一层的是"),t("code",[a._v("Bootstrap")]),a._v("，它是JVM启动时创建的，负责加载对核心的Java类，比如Object、System、String等。\n第二层称为"),t("code",[a._v("Platform")]),a._v(",即平台类加载器，用于加载一些扩展的系统类。比如XML、加密、压缩相关的功能类等，在JDK9之前称为Extension。\n第三层是称为Applocation的应用类加载器，主要加载用户定义的CLASSPATH路径下的类。\n用户也可以自定义类加载器。")]),a._v(" "),t("h1",{attrs:{id:"双亲委派模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型"}},[a._v("#")]),a._v(" 双亲委派模型")]),a._v(" "),t("p",[a._v("双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。\n"),t("img",{attrs:{src:"/images/ref/%E7%B1%BB%E5%8A%A0%E8%BD%BD01.png",alt:"Alt text"}})]),a._v(" "),t("h1",{attrs:{id:"为什么需要双亲委派"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要双亲委派"}},[a._v("#")]),a._v(" 为什么需要双亲委派")]),a._v(" "),t("p",[a._v("为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：")]),a._v(" "),t("p",[a._v("黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，导致“病毒代码”被执行。")]),a._v(" "),t("p",[a._v("而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。")]),a._v(" "),t("p",[a._v("或许你会想，我在自定义的类加载器里面强制加载自定义的java.lang.String类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。")]),a._v(" "),t("p",[a._v("举个简单例子：\nClassLoader1、ClassLoader2都加载java.lang.String类，对应Class1、Class2对象。那么Class1对象不属于ClassLoad2对象加载的java.lang.String类型。")]),a._v(" "),t("h1",{attrs:{id:"自定义类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义类加载器"}},[a._v("#")]),a._v(" 自定义类加载器")]),a._v(" "),t("p",[a._v("什么情况下需要自定义类加载器？")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("隔离加载类/模块/jar\n可以进行环境隔离，不同的 ClassLoader 加载的 class ，在不同环境中，不会相互影响")])]),a._v(" "),t("li",[t("p",[a._v("实现应用的热部署\n如：Tomcat自定义了classLoader")])]),a._v(" "),t("li",[t("p",[a._v("扩展加载源\n比如从数据库、网络的输入流中读取class信息")])]),a._v(" "),t("li",[t("p",[a._v("防止源码泄露\n如果进行了编译加密，类加载器也需要自定义，还原的加密字节码。")])])]),a._v(" "),t("p",[a._v("实现自定义类加载器的步骤：继承ClassLoader，重写findClass()方法，调用defineClass()方法。\n"),t("img",{attrs:{src:"/images/ref/%E7%B1%BB%E5%8A%A0%E8%BD%BD02.png",alt:"Alt text"}})])])}),[],!1,null,null,null);s.default=n.exports}}]);