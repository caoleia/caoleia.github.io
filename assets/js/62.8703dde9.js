(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{409:function(a,v,e){"use strict";e.r(v);var t=e(42),r=Object(t.a)({},(function(){var a=this,v=a.$createElement,e=a._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"什么是内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是内存模型"}},[a._v("#")]),a._v(" 什么是内存模型")]),a._v(" "),e("p",[a._v("内存模型说的是，在多核多线程环境下，各种不同的CPU是如何以一种统一的方式来与内存交互的\n")]),a._v(" "),e("h1",{attrs:{id:"cpu的高速缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cpu的高速缓存"}},[a._v("#")]),a._v(" CPU的高速缓存")]),a._v(" "),e("p",[a._v("CPU和内存并不是直接交换数据的，它们之间还隔着一个高速缓存。高速缓存是对程序员透明的，这意味在编程的时候是感知不到CPU的缓存的存在的。一般情况下确实如此，但在，在某些特殊的情形下（多核多线程），就不能忽略缓存的存在了。这其实是和缓存的设计有关系，一般多处理器下的每个CPU都有一个自己的缓存，存储在这个缓存的数据是其它CPU是无法查看的。")]),a._v(" "),e("h1",{attrs:{id:"内存可见性（缓存一致性）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存可见性（缓存一致性）"}},[a._v("#")]),a._v(" 内存可见性（缓存一致性）")]),a._v(" "),e("p",[a._v("问题来了，由于缓存是每个CPU私有的，那么在多线程环境下，某个CPU修改了变量x后保存在本地缓存，对于其它CPU，何时才能发现变量x被修改呢？如何保证其它CPU的缓存中持有的x的值是最新的呢？")]),a._v(" "),e("p",[a._v("由此可见，在多核多线程环境下，读写共享变量要解决的不仅是原子性，还需要保证其内存可见性。更糟的是，现代CPU通常在执行指令时会允许一定程度上的乱序，这使保证在多个CPU缓存的数据一致更是增加了复杂性。通常方法是通过一个协议来保证数据在各个CPU的缓存是一致性，这就是缓存一致性协议。")]),a._v(" "),e("p",[a._v("关于缓存一致性简单的举个列子。CPU-0尝试STORE（更新）变量x，但其发现其它CPU的缓存也持有这个x的copy（x此时为Shared状态，非单个CPU独占），那么当CPU-0在STORE之前，必须通过一个disable消息，告诉其它CPU所持有的变量x已经为脏数据，是不可用状态。其它CPU在收到这个disable消息后必须回应CPU-0一个ack消息，这时候CPU-0才能开始STORE变量x。")]),a._v(" "),e("p",[a._v("通过缓存一致性协议之后，内存可见性问题似乎是得以解决了。但是，这里面还隐藏着另外一个问题：指令乱序！")]),a._v(" "),e("blockquote",[e("p",[a._v("可以被多个线程访问的变量称为"),e("code",[a._v("共享变量")])])]),a._v(" "),e("h1",{attrs:{id:"乱序（memory-reorder）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#乱序（memory-reorder）"}},[a._v("#")]),a._v(" 乱序（memory reorder）")]),a._v(" "),e("p",[a._v("先来解释一下，乱序，指的是程序指令实际上执行的顺序，和我们书写的指令的顺序不一致。乱序分两种，分别是编译器的指令重排和CPU的乱序执行。本意上乱序是为了优化指令执行的速度而产生的。并且为了维护程序原来的语义，编译器和CPU不会对两个有数据依赖的指令重排（reorder）。这种保护在单线程的环境下是可以工作的，但是到了多线程，问题就复杂了。")]),a._v(" "),e("p",[a._v("举个例子，CPU-0将要执行两条指令，分别是：")]),a._v(" "),e("p",[a._v("STORE x\nLOAD y\n当CPU-0执行指令1的时候，发现这个变量x的当前状态为Shared，这意味着其它CPU也持有了x，因此根据缓存一致性协议，CPU-0在修改x之前必须通知其它CPU，直到收到来自其它CPU的ack才会执行真正的修改x。但是，事情没有这么简单。现代CPU缓存通常都有一个Store Buffer，其存在的目的是，先将要Store的变量记下来，注意此时并不真的执行Store操作，然后待时机合适的时候再执行实际的Store。有了这个Store Buffer，CPU-0在向其它CPU发出disable消息之后并不是干等着，而是转而执行指令2（由于指令1和指令2在CPU-0看来并不存在数据依赖）。这样做效率是有了，但是也带来了问题。虽然我们在写程序的时候，是先STORE x再执行LOAD y，但是实际上CPU却是先LOAD y再STORE x，这个便是CPU乱序执行（reorder）的一种情况！（"),e("code",[a._v("MESI协议")]),a._v(")")]),a._v(" "),e("p",[a._v("当你的程序要求指令1、2有逻辑上的先后顺序时，CPU这样的优化就是有问题的。但是，CPU并不知道指令之间蕴含着什么样的逻辑顺序，在你告诉它之前，它只是假设指令之间都没有逻辑关联，并且尽最大的努力优化执行速度。因此我们需要一种机制能告诉CPU：这段指令执行的顺序是不可被重排的！做这种事的就是内存屏障（memory barrier）！")]),a._v(" "),e("h1",{attrs:{id:"内存屏障"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障"}},[a._v("#")]),a._v(" 内存屏障")]),a._v(" "),e("p",[a._v("还是上面那个例子，如果不想指令1、2被CPU重排，程序应该这么写：")]),a._v(" "),e("p",[a._v("STORE x\nWMB (Write memory barrier)\nLOAD y\n通过在STORE x之后加上这个写内存屏障，就能保证在之后LOAD y指令不会被重排到STORE x之前了。")]),a._v(" "),e("h1",{attrs:{id:"什么是内存模型-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是内存模型-2"}},[a._v("#")]),a._v(" 什么是内存模型")]),a._v(" "),e("p",[a._v("前面讲了那么多，那么内存模型是什么呢？")]),a._v(" "),e("p",[a._v("首先，残酷的现实就是每个CPU设计都是不同的，每个CPU对指令乱序的程度也是不一样的。比较保守的如x86仅会对Store Load乱序，但是一些优化激进的CPU（PS的Power）会允许更多情况的乱序产生。如果目标是写一个跨平台多线程的程序，那么势必要了解每一个CPU的细节，来插入确切的、足够的内存屏障来保证程序的正确性。这是多么的不科学啊！科学的做法应该是，我为一个抽象的机器写一套抽象的程序，然后在不同的平台下让编程语言、编译器来生成合适的内存屏障。因此，我们有了内存模型的概念。不同平台下的实现差别被统一的内存模型所隐藏，只需要根据这个抽象的内存模型来编写程序即可，这便是伟大的抽象...")]),a._v(" "),e("h1",{attrs:{id:"并发编程中的三个概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发编程中的三个概念"}},[a._v("#")]),a._v(" 并发编程中的三个概念")]),a._v(" "),e("p",[a._v("在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。")])]),a._v(" "),e("li",[e("p",[a._v("可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。")])]),a._v(" "),e("li",[e("p",[a._v("有序性：即程序执行的顺序按照代码的先后顺序执行")])])]),a._v(" "),e("p",[a._v("要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。")]),a._v(" "),e("h1",{attrs:{id:"java内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型"}},[a._v("#")]),a._v(" Java内存模型")]),a._v(" "),e("p",[a._v("Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。")]),a._v(" "),e("p",[a._v("那么Java内存模型规定了哪些东西呢，"),e("code",[a._v("它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序")]),a._v("。")]),a._v(" "),e("p",[a._v("为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。")]),a._v(" "),e("p",[a._v("Java内存模型规定所有的变量都是存在"),e("code",[a._v("主存")]),a._v("当中（类似于前面说的物理内存），每个线程都有自己的"),e("code",[a._v("工作内存")]),a._v("（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\n(与内存模型的概念是一样的)")]),a._v(" "),e("p",[a._v("举例：")]),a._v(" "),e("div",{staticClass:"language-Java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[a._v("i"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。")]),a._v(" "),e("blockquote",[e("p",[a._v("这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。")])]),a._v(" "),e("h2",{attrs:{id:"java语言对原子性、可见性以及有序性的保证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java语言对原子性、可见性以及有序性的保证"}},[a._v("#")]),a._v(" Java语言对原子性、可见性以及有序性的保证")]),a._v(" "),e("ol",[e("li",[a._v("原子性\n"),e("code",[a._v("在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行")])])]),a._v(" "),e("p",[a._v("上面一句话虽然看起来简单，但是理解起来并不是那么容易。")]),a._v(" "),e("div",{staticClass:"language-Java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[a._v("x "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("         "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句1")]),a._v("\ny "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("         "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句2")]),a._v("\nx"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("           "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句3")]),a._v("\nx "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("     "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句4 ")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br")])]),e("p",[a._v("以上语句只有语句1是原子性操作，语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存...\n也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作")]),a._v(" "),e("p",[a._v("从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过"),e("code",[a._v("synchronized")]),a._v("和"),e("code",[a._v("Lock")]),a._v("来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。")]),a._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[a._v("可见性\n对于可见性，Java提供了volatile关键字来保证可见性。")])]),a._v(" "),e("p",[a._v("当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。")]),a._v(" "),e("p",[a._v("而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。")]),a._v(" "),e("p",[a._v("另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。")]),a._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[a._v("有序性\n在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。")])]),a._v(" "),e("p",[a._v("在Java里面，可以通过volatile关键字来保证一定的“有序性”（直接从主从中获取共享变量,不需要其他线程ack,这种情况就不会发生乱序）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。")]),a._v(" "),e("p",[a._v("另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为"),e("code",[a._v("happens-before")]),a._v("原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。")]),a._v(" "),e("p",[a._v("下面就来具体介绍下happens-before原则（先行发生原则）：")]),a._v(" "),e("ul",[e("li",[a._v("程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作")]),a._v(" "),e("li",[a._v("锁定规则：同一个lock锁，必须先进行了unlock释放，才能继续加锁")]),a._v(" "),e("li",[a._v("volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n（如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。）")]),a._v(" "),e("li",[a._v("传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C")]),a._v(" "),e("li",[a._v("线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作")]),a._v(" "),e("li",[a._v("线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生")]),a._v(" "),e("li",[a._v("线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行")]),a._v(" "),e("li",[a._v("对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始")])])])}),[],!1,null,null,null);v.default=r.exports}}]);