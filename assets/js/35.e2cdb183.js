(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{382:function(l,v,a){"use strict";a.r(v);var t=a(42),e=Object(t.a)({},(function(){var l=this,v=l.$createElement,a=l._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[a("h1",{attrs:{id:"关键字-volatile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关键字-volatile"}},[l._v("#")]),l._v(" 关键字: volatile")]),l._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#带着问题去理解volatile"}},[l._v("带着问题去理解volatile")])]),a("li",[a("a",{attrs:{href:"#volatile的java语义"}},[l._v("volatile的Java语义")]),a("ul",[a("li",[a("a",{attrs:{href:"#禁止重排序"}},[l._v("禁止重排序")])]),a("li",[a("a",{attrs:{href:"#实现可见性"}},[l._v("实现可见性")])]),a("li",[a("a",{attrs:{href:"#保证原子性-单次读-写"}},[l._v("保证原子性:单次读/写")])])])]),a("li",[a("a",{attrs:{href:"#volatile-的实现原理"}},[l._v("volatile 的实现原理")]),a("ul",[a("li",[a("a",{attrs:{href:"#volatile-可见性实现"}},[l._v("volatile 可见性实现")])]),a("li",[a("a",{attrs:{href:"#volatile-有序性实现"}},[l._v("volatile 有序性实现")])]),a("li",[a("a",{attrs:{href:"#volatile-禁止重排序"}},[l._v("volatile 禁止重排序")])])])])])]),a("p"),l._v(" "),a("h2",{attrs:{id:"带着问题去理解volatile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#带着问题去理解volatile"}},[l._v("#")]),l._v(" 带着问题去理解volatile")]),l._v(" "),a("ul",[a("li",[l._v("volatile关键字的作用是什么?")]),l._v(" "),a("li",[l._v("volatile能保证原子性吗?")]),l._v(" "),a("li",[l._v("之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?")]),l._v(" "),a("li",[l._v("i++为什么不能保证原子性?")]),l._v(" "),a("li",[l._v("volatile是如何实现可见性的? 内存屏障。")]),l._v(" "),a("li",[l._v("volatile是如何实现有序性的? happens-before等")])]),l._v(" "),a("h2",{attrs:{id:"volatile的java语义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile的java语义"}},[l._v("#")]),l._v(" volatile的Java语义")]),l._v(" "),a("h3",{attrs:{id:"禁止重排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁止重排序"}},[l._v("#")]),l._v(" 禁止重排序")]),l._v(" "),a("p",[l._v("实例化一个对象其实可以分为三个步骤：")]),l._v(" "),a("ul",[a("li",[l._v("分配内存空间。")]),l._v(" "),a("li",[l._v("初始化对象。")]),l._v(" "),a("li",[l._v("将内存空间的地址赋值给对应的引用。")])]),l._v(" "),a("p",[l._v("但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：")]),l._v(" "),a("ul",[a("li",[l._v("分配内存空间。")]),l._v(" "),a("li",[l._v("将内存空间的地址赋值给对应的引用。")]),l._v(" "),a("li",[l._v("初始化对象")])]),l._v(" "),a("p",[l._v("如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。\n因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量，volatile具有禁止重排序的java语义。")]),l._v(" "),a("h3",{attrs:{id:"实现可见性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现可见性"}},[l._v("#")]),l._v(" 实现可见性")]),l._v(" "),a("p",[l._v("可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题。")]),l._v(" "),a("h3",{attrs:{id:"保证原子性-单次读-写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保证原子性-单次读-写"}},[l._v("#")]),l._v(" 保证原子性:单次读/写")]),l._v(" "),a("p",[l._v("基于volatile保证单次的读/写操作具有原子性的理解，你将能够理解如下两个问题：")]),l._v(" "),a("p",[a("strong",[l._v("问题1： i++为什么不能保证原子性?")])]),l._v(" "),a("p",[l._v("对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。")]),l._v(" "),a("p",[a("strong",[l._v("问题： 共享的long和double变量的为什么要用volatile?")])]),l._v(" "),a("p",[l._v("因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。")]),l._v(" "),a("p",[l._v("目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。")]),l._v(" "),a("h2",{attrs:{id:"volatile-的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-的实现原理"}},[l._v("#")]),l._v(" volatile 的实现原理")]),l._v(" "),a("h3",{attrs:{id:"volatile-可见性实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-可见性实现"}},[l._v("#")]),l._v(" volatile 可见性实现")]),l._v(" "),a("blockquote",[a("p",[l._v("volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现")])]),l._v(" "),a("p",[l._v("在了解volatile实现原理之前，先看一下与CPU相关的一些术语")]),l._v(" "),a("ul",[a("li",[l._v("内存屏障 又称内存栅栏，是一个 CPU 指令，用于实现对内存操作的顺序限制。")]),l._v(" "),a("li",[l._v("缓冲行 CPU高速缓存中可以分配的最小存储单位")]),l._v(" "),a("li",[l._v("缓存行填充 当CPU识别到从内存中读取操作数是可缓存的，读取整个高速缓存行到适当的缓存(L1、L2、L3或所有)")])]),l._v(" "),a("blockquote",[a("p",[l._v("在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。")])]),l._v(" "),a("p",[l._v("写一段简单的 Java 代码，声明一个 volatile 变量，并赋值。\n通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码\n在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令\nlock 前缀的指令在多核处理器下会引发两件事情:")]),l._v(" "),a("ul",[a("li",[l._v("将当前处理器缓存行的数据写回到系统内存")]),l._v(" "),a("li",[l._v("写回内存的操作会使在其他 CPU 里缓存了该内存地址的额数据无效（缓存一致性协议）")])]),l._v(" "),a("p",[l._v("为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。")]),l._v(" "),a("p",[l._v("如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。")]),l._v(" "),a("p",[l._v("为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。")]),l._v(" "),a("p",[l._v("所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。")]),l._v(" "),a("p",[l._v("volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。")]),l._v(" "),a("h3",{attrs:{id:"volatile-有序性实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-有序性实现"}},[l._v("#")]),l._v(" volatile 有序性实现")]),l._v(" "),a("p",[l._v("happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。")]),l._v(" "),a("h3",{attrs:{id:"volatile-禁止重排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volatile-禁止重排序"}},[l._v("#")]),l._v(" volatile 禁止重排序")]),l._v(" "),a("p",[l._v("Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。")])])}),[],!1,null,null,null);v.default=e.exports}}]);