(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{405:function(a,t,e){"use strict";e.r(t);var v=e(42),s=Object(v.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("根据《Java虚拟机规范》的规定，经典的JVM内存布局包括这几个部分：\n程序计数器(Program Counter Register)、虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)元数据区(Metaspace)、堆(Heap)。\n"),e("img",{attrs:{src:"/images/ref/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%8001.png",alt:"Alt text"}})]),a._v(" "),e("p",[a._v("Java虚拟机在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机，其中元数据区、堆代表的是所有线程共享的数据区域，而其他部分代表的是每个线程的私有数据区域。\n")]),a._v(" "),e("h1",{attrs:{id:"heap-堆区）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#heap-堆区）"}},[a._v("#")]),a._v(" Heap(堆区）")]),a._v(" "),e("p",[a._v("Heap是OOM(OutOfMemoneyError)故障最主要的发源地。\n存储着几乎所有的实例对象，在C语言中，堆这部分空间是唯一一个程序员可以管理的内存区域，\n程序员可以通过malloc函数和free函数在堆上申请和释放空间，在Java中堆由垃圾收集器自动回收。")]),a._v(" "),e("p",[a._v("通常情况下占用的内存区域是最大的，堆空间既可以固定大小也可以在运行时动态调整。\n"),e("code",[a._v("-Xms256M -Xmx1024M(ms:memory start,mx:memory max)")]),a._v("\n在运行过程中堆空间动态的扩容与回缩会造成不小的系统压力，在生产环境中一般设置同样的大小。")]),a._v(" "),e("p",[a._v("堆分成两大块，新生代和老年代。新生代 = 1个Eden区+ 2个Survivor区。\n绝大部分对象在Eden区生产，当Eden区装填满的时候，会触发Young Garbage Collection，即"),e("code",[a._v("YGC")]),a._v("。\n垃圾回收的时候在Eden区实现清除策略，没有被引用的对象直接被回收。存活的对象被交替移动到Survivor区的其中一个，S0或S1。\n如果移动的时候超过了Survivor区的容量，就直接移交到老年代。\n每个对象都有一个计数器，默认值是15，一个对象在幸存区被交换14次后就会被移动到老年代。\n"),e("code",[a._v("-XX:MaxTenuringThreshold")]),a._v("配置计数器的阀值。")]),a._v(" "),e("p",[a._v("如果老年代也无法放下，会触发Full Garbage Collection，即"),e("code",[a._v("FGC")]),a._v("。如果依然无法放下，抛出OOM。\n堆内存出现OOM的异常是最高的，出错时堆内信息对解决问题非常有帮助，给JVM设置运行参数"),e("code",[a._v("-XX:HeapDumpOnOutOfMemoryError")]),a._v(",\n让JVM遇到OOM异常时能够输出堆内信息。\n"),e("img",{attrs:{src:"/images/ref/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%8002.png",alt:"Alt text"}})]),a._v(" "),e("h1",{attrs:{id:"metaspace-元空间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#metaspace-元空间"}},[a._v("#")]),a._v(" Metaspace(元空间)")]),a._v(" "),e("p",[a._v("元空间，它与堆一样，是被线程共享的区域。元空间前身为方法区，对应永久代(Perm)。在JDK7及之前才有Perm区，在启动时固定大小。\n在某些场景下，如果动态加载的类过多，容易产生Perm区的OOM："),e("code",[a._v("java.lang.OutOfMemoryError:PermGenspace")]),a._v("。\n为了解决该问题，需要设置运行参数"),e("code",[a._v("-XX:MaxPermSize=1280M")]),a._v(".")]),a._v(" "),e("p",[a._v("永久代在垃圾回收过程中还存在诸多问题，所以在JDK8使用元空间替换永久代。\nPerm区中字符串常量移动至堆内存，类元信息（包括类的名称、方法信息、字段信息）移动至元空间内。")]),a._v(" "),e("h1",{attrs:{id:"jvm-stack（虚拟机栈）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm-stack（虚拟机栈）"}},[a._v("#")]),a._v(" JVM Stack（虚拟机栈）")]),a._v(" "),e("p",[a._v("JVM中的虚拟机栈是描述Java方法执行的内存区域，它是线程私有的。\n栈中的每一个元素称为栈帧，用于支持虚拟机进行方法调用。\n当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。\n当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。\nStackOverflowError表示请求的栈溢出，通常出现在递归方法中。")]),a._v(" "),e("p",[a._v("Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、动态链接、方法返回地址(Return Address)。")]),a._v(" "),e("p",[a._v("由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。")]),a._v(" "),e("h2",{attrs:{id:"局部变量表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#局部变量表"}},[a._v("#")]),a._v(" 局部变量表")]),a._v(" "),e("p",[a._v("就是用来存储方法中的"),e("code",[a._v("局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。")])]),a._v(" "),e("h2",{attrs:{id:"操作数栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作数栈"}},[a._v("#")]),a._v(" 操作数栈")]),a._v(" "),e("p",[a._v("在方法执行过程中，会有各种指令往栈中写入和提取信息。\n栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。")]),a._v(" "),e("h2",{attrs:{id:"动态链接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态链接"}},[a._v("#")]),a._v(" 动态链接")]),a._v(" "),e("p",[a._v("每个栈帧中包含一个在常量池中对当前方法的引用，目的是可以调用常量池中的常量。\n因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。")]),a._v(" "),e("h2",{attrs:{id:"方法返回地址"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法返回地址"}},[a._v("#")]),a._v(" 方法返回地址")]),a._v(" "),e("p",[a._v("当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。")]),a._v(" "),e("h1",{attrs:{id:"native-method-stacks（本地方法栈）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#native-method-stacks（本地方法栈）"}},[a._v("#")]),a._v(" Native Method Stacks（本地方法栈）")]),a._v(" "),e("p",[a._v("本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方法的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一")]),a._v(" "),e("h1",{attrs:{id:"程序计数器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),e("p",[a._v("程序计数器（Program Counter Register），也有称作为PC寄存器。想必学过汇编语言的朋友对程序计数器这个概念并不陌生，在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。")]),a._v(" "),e("p",[a._v("虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示 执行哪条指令的。")]),a._v(" "),e("p",[a._v("由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。")]),a._v(" "),e("p",[a._v("在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。")]),a._v(" "),e("p",[a._v("由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。")]),a._v(" "),e("h1",{attrs:{id:"对象实例化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象实例化"}},[a._v("#")]),a._v(" 对象实例化")]),a._v(" "),e("p",[a._v("在实例化对象的过程中，JVM发生了什么？")]),a._v(" "),e("div",{staticClass:"language-Java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" ref "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("从执行步骤分析：")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("确认类元信息是否存在。\n当JVM接收到new指令时，首先在元空间查找类原信息是否存在。\n若不存在，在双亲委派模式下，使用当前类的加载器以ClassLoader+包名+类名为key查找对应的.class文件。\n如果没有找到文件，则抛出ClassNotFoundException异常；如果找到则进行类假造，并生产对应的Class对象。")])]),a._v(" "),e("li",[e("p",[a._v("分配对象内存。\n首先计算对象所占用空间大小，如果成员变量是引用变量则仅分配引用变量空间即可，4个字节大小。\n接着在堆中划分一块内存给新对象。在分配内存空间时需要进行同步操作，比如采用CAS、区域枷锁等方式保证分配操作的原子性。")])]),a._v(" "),e("li",[e("p",[a._v("设置默认值，设置成员变量的默认值。")])]),a._v(" "),e("li",[e("p",[a._v("设置对象头。\n设置新对象的哈希码、GC信息、锁信息、随想所属的类元信息等。这个过程是由JVM具体实现的。")])]),a._v(" "),e("li",[e("p",[a._v("执行init方法\n初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);