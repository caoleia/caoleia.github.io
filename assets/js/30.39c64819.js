(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{376:function(a,t,s){"use strict";s.r(t);var n=s(42),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"关键字-final详解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关键字-final详解"}},[a._v("#")]),a._v(" 关键字: final详解")]),a._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#带着bat大厂的面试问题去理解final"}},[a._v("带着BAT大厂的面试问题去理解final")])]),s("li",[s("a",{attrs:{href:"#final基础使用"}},[a._v("final基础使用")]),s("ul",[s("li",[s("a",{attrs:{href:"#修饰类"}},[a._v("修饰类")])]),s("li",[s("a",{attrs:{href:"#修饰方法"}},[a._v("修饰方法")])]),s("li",[s("a",{attrs:{href:"#修饰参数"}},[a._v("修饰参数")])]),s("li",[s("a",{attrs:{href:"#修饰变量"}},[a._v("修饰变量")])])])]),s("li",[s("a",{attrs:{href:"#再思考一个有趣的现象"}},[a._v("再思考一个有趣的现象")])])])]),s("p"),a._v(" "),s("h2",{attrs:{id:"带着bat大厂的面试问题去理解final"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#带着bat大厂的面试问题去理解final"}},[a._v("#")]),a._v(" 带着BAT大厂的面试问题去理解final")]),a._v(" "),s("ul",[s("li",[a._v("所有的final修饰的字段都是编译期常量吗?")]),a._v(" "),s("li",[a._v("如何理解private所修饰的方法是隐式的final?")]),a._v(" "),s("li",[a._v("说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做?")]),a._v(" "),s("li",[a._v("final方法可以被重载吗? 可以")]),a._v(" "),s("li",[a._v("父类的final方法能不能够被子类重写? 不可以")]),a._v(" "),s("li",[a._v("说说final域重排序规则?")]),a._v(" "),s("li",[a._v("说说final的原理?")]),a._v(" "),s("li",[a._v("使用 final 的限制条件和局限性?")])]),a._v(" "),s("h2",{attrs:{id:"final基础使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#final基础使用"}},[a._v("#")]),a._v(" final基础使用")]),a._v(" "),s("h3",{attrs:{id:"修饰类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修饰类"}},[a._v("#")]),a._v(" 修饰类")]),a._v(" "),s("p",[a._v("当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。")]),a._v(" "),s("p",[a._v("注意：final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。")]),a._v(" "),s("p",[a._v("这里顺道说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做?")]),a._v(" "),s("p",[a._v("设计模式中最重要的两种关系，一种是继承/实现；另外一种是组合关系。所以当遇到不能用继承的(final修饰的类),应该考虑用组合。")]),a._v(" "),s("h3",{attrs:{id:"修饰方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修饰方法"}},[a._v("#")]),a._v(" 修饰方法")]),a._v(" "),s("ul",[s("li",[a._v("不能被子类重写")]),a._v(" "),s("li",[a._v("private 方法是隐式的final")]),a._v(" "),s("li",[a._v("final方法是可以被重载的")])]),a._v(" "),s("h3",{attrs:{id:"修饰参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修饰参数"}},[a._v("#")]),a._v(" 修饰参数")]),a._v(" "),s("p",[a._v("Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。")]),a._v(" "),s("h3",{attrs:{id:"修饰变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修饰变量"}},[a._v("#")]),a._v(" 修饰变量")]),a._v(" "),s("h4",{attrs:{id:"static-final"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#static-final"}},[a._v("#")]),a._v(" static final")]),a._v(" "),s("p",[a._v("一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。")]),a._v(" "),s("h4",{attrs:{id:"blank-final"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#blank-final"}},[a._v("#")]),a._v(" blank final")]),a._v(" "),s("p",[a._v("Java允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择：")]),a._v(" "),s("ul",[s("li",[a._v("在定义处进行赋值(这不叫空白final)")]),a._v(" "),s("li",[a._v("在构造器中进行赋值，保证了该值在被使用前赋值。\n这增强了final的灵活性。")])]),a._v(" "),s("h2",{attrs:{id:"再思考一个有趣的现象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#再思考一个有趣的现象"}},[a._v("#")]),a._v(" 再思考一个有趣的现象")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("byte")]),a._v(" b1"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("byte")]),a._v(" b2"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("byte")]),a._v(" b3"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("b1"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v("b2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//当程序执行到这一行的时候会出错，因为b1、b2可以自动转换成int类型的变量，运算时java虚拟机对它进行了转换，结果导致把一个int赋值给byte-----出错")]),a._v("\n  \n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("如果对b1 b2加上final就不会出错")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("byte")]),a._v(" b1"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("byte")]),a._v(" b2"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("byte")]),a._v(" b3"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("b1"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v("b2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//不会出错")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("p",[a._v("原因：\nJava定义了若干使用于表达式的类型提升规则：")]),a._v(" "),s("ol",[s("li",[a._v("所有的byte型，short型和char型将被提升到int型(例外: final修饰的short, char变量相加后不会被自动提升。)")]),a._v(" "),s("li",[a._v("如果一个操作数是long形 计算结果就是long型;")]),a._v(" "),s("li",[a._v("如果一个操作数是float型，计算结果就是float型;")]),a._v(" "),s("li",[a._v("如果一个操作数是double型，计算结果就是double型;")])]),a._v(" "),s("p",[a._v("另一种归纳方式(《Java核心技术卷I》P43):")]),a._v(" "),s("ol",[s("li",[a._v("如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。")]),a._v(" "),s("li",[a._v("否则，如果其中一个操作数是float类型，另一个将会转换为float类型。")]),a._v(" "),s("li",[a._v("否则，如果其中一个操作数是long类型，另一个会转换为long类型。")]),a._v(" "),s("li",[a._v("否则，两个操作数都转换为int类型。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);