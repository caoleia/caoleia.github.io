(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{375:function(a,s,t){"use strict";t.r(s);var n=t(42),e=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"java-并发-理论基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-并发-理论基础"}},[a._v("#")]),a._v(" Java 并发 - 理论基础")]),a._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#带着bat大厂的面试问题去理解"}},[a._v("带着BAT大厂的面试问题去理解")])]),t("li",[t("a",{attrs:{href:"#为什么需要多线程"}},[a._v("为什么需要多线程")])]),t("li",[t("a",{attrs:{href:"#并发出现问题的根源-并发三要素"}},[a._v("并发出现问题的根源: 并发三要素")]),t("ul",[t("li",[t("a",{attrs:{href:"#可见性-cpu缓存引起"}},[a._v("可见性: CPU缓存引起")])]),t("li",[t("a",{attrs:{href:"#原子性-分时复用引起"}},[a._v("原子性: 分时复用引起")])]),t("li",[t("a",{attrs:{href:"#有序性-重排序引起"}},[a._v("有序性: 重排序引起")])])])]),t("li",[t("a",{attrs:{href:"#java是怎么解决并发问题的-jmm-java内存模型"}},[a._v("JAVA是怎么解决并发问题的: JMM(Java内存模型)")]),t("ul",[t("li",[t("a",{attrs:{href:"#happens-before-规则"}},[a._v("Happens-Before 规则")])]),t("li",[t("a",{attrs:{href:"#as-if-serial语义"}},[a._v("as-if-serial语义")])])])]),t("li",[t("a",{attrs:{href:"#线程安全的实现方法"}},[a._v("线程安全的实现方法")]),t("ul",[t("li",[t("a",{attrs:{href:"#_1-互斥同步（阻塞同步）"}},[a._v("1. 互斥同步（阻塞同步）")])]),t("li",[t("a",{attrs:{href:"#_2-非阻塞同步"}},[a._v("2. 非阻塞同步")])]),t("li",[t("a",{attrs:{href:"#无同步方案"}},[a._v("无同步方案")])])])])])]),t("p"),a._v(" "),t("h2",{attrs:{id:"带着bat大厂的面试问题去理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#带着bat大厂的面试问题去理解"}},[a._v("#")]),a._v(" 带着BAT大厂的面试问题去理解")]),a._v(" "),t("ul",[t("li",[a._v("多线程的出现是要解决什么问题的?")]),a._v(" "),t("li",[a._v("线程不安全是指什么? 举例说明")]),a._v(" "),t("li",[a._v("并发出现线程不安全的本质什么? 可见性，原子性和有序性。")]),a._v(" "),t("li",[a._v("Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before")]),a._v(" "),t("li",[a._v("线程安全有哪些实现思路?")]),a._v(" "),t("li",[a._v("如何理解并发和并行的区别?")])]),a._v(" "),t("h2",{attrs:{id:"为什么需要多线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要多线程"}},[a._v("#")]),a._v(" 为什么需要多线程")]),a._v(" "),t("p",[a._v("CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:")]),a._v(" "),t("ul",[t("li",[a._v("CPU 增加了缓存，以均衡与内存的速度差异；// 导致 可见性问题")]),a._v(" "),t("li",[a._v("操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 原子性问题")]),a._v(" "),t("li",[a._v("编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题")])]),a._v(" "),t("h2",{attrs:{id:"并发出现问题的根源-并发三要素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发出现问题的根源-并发三要素"}},[a._v("#")]),a._v(" 并发出现问题的根源: 并发三要素")]),a._v(" "),t("h3",{attrs:{id:"可见性-cpu缓存引起"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可见性-cpu缓存引起"}},[a._v("#")]),a._v(" 可见性: CPU缓存引起")]),a._v(" "),t("p",[a._v("可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。 举个简单的例子，看下面这段代码：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程1执行的代码")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\ni "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n \n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程2执行的代码")]),a._v("\nj "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("p",[a._v("假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。")]),a._v(" "),t("p",[a._v("此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.")]),a._v(" "),t("p",[a._v("这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。")]),a._v(" "),t("h3",{attrs:{id:"原子性-分时复用引起"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原子性-分时复用引起"}},[a._v("#")]),a._v(" 原子性: 分时复用引起")]),a._v(" "),t("h3",{attrs:{id:"有序性-重排序引起"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有序性-重排序引起"}},[a._v("#")]),a._v(" 有序性: 重排序引起")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("              \n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" flag "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\ni "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("                "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句1  ")]),a._v("\nflag "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("          "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句2")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("p",[a._v("上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。")]),a._v(" "),t("p",[a._v("在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：")]),a._v(" "),t("ul",[t("li",[a._v("编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。")]),a._v(" "),t("li",[a._v("指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。")]),a._v(" "),t("li",[a._v("内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。")])]),a._v(" "),t("p",[a._v("从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：")]),a._v(" "),t("p",[t("img",{attrs:{src:"/_images/java-jmm-3.png",alt:"java-jmm-3"}})]),a._v(" "),t("p",[a._v("著作权归https://www.pdai.tech所有。\n链接：https://www.pdai.tech/md/java/thread/java-thread-x-theorty.html")]),a._v(" "),t("p",[a._v("上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。")]),a._v(" "),t("h2",{attrs:{id:"java是怎么解决并发问题的-jmm-java内存模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java是怎么解决并发问题的-jmm-java内存模型"}},[a._v("#")]),a._v(" JAVA是怎么解决并发问题的: JMM(Java内存模型)")]),a._v(" "),t("p",[t("code",[a._v("理解的第一个维度：核心知识点")]),a._v("\nJMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：")]),a._v(" "),t("ul",[t("li",[a._v("volatile、synchronized 和 final 三个关键字")]),a._v(" "),t("li",[a._v("Happens-Before 规则")])]),a._v(" "),t("p",[t("code",[a._v("理解的第二个维度：可见性，有序性，原子性")])]),a._v(" "),t("ul",[t("li",[a._v("原子性")])]),a._v(" "),t("p",[a._v("在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 请分析以下哪些操作是原子性操作：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("x "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("        "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中")]),a._v("\ny "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("         "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。")]),a._v("\nx"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("           "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。")]),a._v("\nx "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("     "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句4： 同语句3")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("p",[a._v("上面4个语句只有语句1的操作具备原子性。")]),a._v(" "),t("p",[a._v("也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。")]),a._v(" "),t("ul",[t("li",[a._v("可见性\nJava提供了volatile关键字来保证可见性。")])]),a._v(" "),t("p",[a._v("当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。")]),a._v(" "),t("p",[a._v("而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。")]),a._v(" "),t("p",[a._v("另外，通过synchronized和final也能够保证可见性。")]),a._v(" "),t("ul",[t("li",[a._v("有序性\n在Java里面，可以通过volatile关键字禁止重排序来保证一定的“有序性”。\n另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。")])]),a._v(" "),t("h3",{attrs:{id:"happens-before-规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#happens-before-规则"}},[a._v("#")]),a._v(" Happens-Before 规则")]),a._v(" "),t("p",[a._v("上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("单一线程原则 Single Thread rule\n在一个线程内，在程序前面的操作先行发生于后面的操作。")])]),a._v(" "),t("li",[t("p",[a._v("管程锁定规则 Monitor Lock Rule\n一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。")])]),a._v(" "),t("li",[t("p",[a._v("volatile变量规则 Volatile Variable Rule\n对一个volatile变量的写操作先行发生于后面对这个变量的读操作。")])]),a._v(" "),t("li",[t("p",[a._v("线程启动规则 Thread Start Rule\nThread 对象的 start() 方法调用先行发生于此线程的每一个动作。")])]),a._v(" "),t("li",[t("p",[a._v("线程加入规则 Thread Join Rule\nThread 对象的结束先行发生于 join() 方法返回。")])]),a._v(" "),t("li",[t("p",[a._v("线程中断规则 Thread Interruption Rule\n对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。")])]),a._v(" "),t("li",[t("p",[a._v("对象终结规则 Finalizer Rule\n一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。")])]),a._v(" "),t("li",[t("p",[a._v("传递性 Transitivity\n如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。")])])]),a._v(" "),t("h3",{attrs:{id:"as-if-serial语义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#as-if-serial语义"}},[a._v("#")]),a._v(" as-if-serial语义")]),a._v(" "),t("p",[a._v("无论什么语言，不管怎么重排序，单线程程序的执行结果不能改变，这就是单线程程序的重排序规则。")]),a._v(" "),t("p",[a._v("换句话说，只要操作之间没有数据依赖性，编译器和CPU都可以任务重排序，因为执行结果不会改变，代码看起来就像是按照顺序一行行从头执行到尾，这就是as-if-serial语义。")]),a._v(" "),t("h2",{attrs:{id:"线程安全的实现方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程安全的实现方法"}},[a._v("#")]),a._v(" 线程安全的实现方法")]),a._v(" "),t("h3",{attrs:{id:"_1-互斥同步（阻塞同步）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-互斥同步（阻塞同步）"}},[a._v("#")]),a._v(" 1. 互斥同步（阻塞同步）")]),a._v(" "),t("p",[a._v("synchronized 和 ReentrantLock。")]),a._v(" "),t("h3",{attrs:{id:"_2-非阻塞同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-非阻塞同步"}},[a._v("#")]),a._v(" 2. 非阻塞同步")]),a._v(" "),t("p",[a._v("互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。")]),a._v(" "),t("p",[a._v("互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。")]),a._v(" "),t("p",[a._v("CAS（自旋）\n随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。")]),a._v(" "),t("p",[a._v("乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。")]),a._v(" "),t("h3",{attrs:{id:"无同步方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无同步方案"}},[a._v("#")]),a._v(" 无同步方案")]),a._v(" "),t("p",[a._v("要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。")]),a._v(" "),t("ol",[t("li",[a._v("栈封闭\n多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。")])]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("util"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("concurrent")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ExecutorService")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("util"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("concurrent")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Executors")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("StackClosedExample")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("add100")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" cnt "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" i "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" i"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            cnt"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("cnt"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  \n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br")])]),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("StackClosedExample")]),a._v(" example "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("StackClosedExample")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ExecutorService")]),a._v(" executorService "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Executors")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("newCachedThreadPool")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    executorService"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("execute")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" example"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("add100")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    executorService"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("execute")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" example"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("add100")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    executorService"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("shutdown")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),a._v("\n\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br")])]),t("ol",{attrs:{start:"2"}},[t("li",[a._v("线程本地存储(Thread Local Storage)\n如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。")])]),a._v(" "),t("p",[a._v("符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。")]),a._v(" "),t("p",[a._v("可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。")]),a._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[a._v("可重入代码(Reentrant Code)\n这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);