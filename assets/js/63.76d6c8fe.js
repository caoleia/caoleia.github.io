(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{407:function(a,t,v){"use strict";v.r(t);var o=v(42),_=Object(o.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("p",[a._v("GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。\n")]),a._v(" "),v("h1",{attrs:{id:"gc-roots"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc-roots"}},[a._v("#")]),a._v(" GC Roots")]),a._v(" "),v("p",[a._v("方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。\n常说的GC(Garbage Collector) roots，特指的是垃圾收集器（Garbage Collector）的对象，GC会收集那些不是GC roots且没有被GC roots引用的对象。")]),a._v(" "),v("p",[a._v("一个对象可以属于多个root，GC root有几下种：")]),a._v(" "),v("ul",[v("li",[a._v("Class - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，"),v("code",[a._v("他们可以以静态字段的方式保存持有其它对象")]),a._v("。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots")]),a._v(" "),v("li",[a._v("Thread - 活着的线程")]),a._v(" "),v("li",[a._v("Stack Local - Java方法的local变量或参数")]),a._v(" "),v("li",[a._v("JNI Local - JNI方法的local变量或参数")]),a._v(" "),v("li",[a._v("JNI Global - 全局JNI引用")]),a._v(" "),v("li",[a._v("Monitor Used - 用于同步的监控对象")]),a._v(" "),v("li",[a._v('Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此需要去确定哪些是属于"JVM持有"的了。')])]),a._v(" "),v("p",[a._v("简单理解：类静态属性中引用的对象、常量引用的对象、虚拟机栈中引用的对象、本地方法栈中引用的对象")]),a._v(" "),v("h1",{attrs:{id:"标记-整理-标记-压缩-算法-fgc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记-整理-标记-压缩-算法-fgc"}},[a._v("#")]),a._v(" 标记-整理(标记-压缩)算法-FGC")]),a._v(" "),v("p",[a._v("对于老年代，首先会从GC Roots触发标记存活的对象，然后将存活的对象整理到内存空间的一端，形成连续的已使用空间，\n最后把已使用空间之外的部分全部清理掉。")]),a._v(" "),v("h1",{attrs:{id:"gc复制算法（mark-copy）-ygc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc复制算法（mark-copy）-ygc"}},[a._v("#")]),a._v(" GC复制算法（Mark-Copy）-YGC")]),a._v(" "),v("p",[a._v("对于新生代，为了能够并行的进行标记和整理将空间分为三块，使用Eden/S0/S1三个分区。\n平均分成A/B块太浪费内存，采用Eden/S0/S1三个区更合理，空间比例为Eden:S0:S1==8:1:1，有效内存（即可分配新生对象的内存）是总内存的9/10。\n算法过程：")]),a._v(" "),v("ol",[v("li",[a._v("Eden+S0可分配新生对象；")]),a._v(" "),v("li",[a._v("对Eden+S0进行垃圾收集，存活对象复制到S1。清理Eden+S0。一次新生代GC结束（YGC）。")]),a._v(" "),v("li",[a._v("Eden+S1可分配新生对象；")]),a._v(" "),v("li",[a._v("对Eden+S1进行垃圾收集，存活对象复制到S0。清理Eden+S1。二次新生代GC结束(YGC)。")]),a._v(" "),v("li",[a._v("goto 1。")])]),a._v(" "),v("h1",{attrs:{id:"ygc和fgc是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ygc和fgc是什么"}},[a._v("#")]),a._v(" YGC和FGC是什么")]),a._v(" "),v("p",[a._v("YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。")]),a._v(" "),v("p",[a._v("FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发fgc，有时10天或一周左右会有一次。")]),a._v(" "),v("h1",{attrs:{id:"什么时候执行ygc和fgc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么时候执行ygc和fgc"}},[a._v("#")]),a._v(" 什么时候执行YGC和FGC")]),a._v(" "),v("p",[a._v("a.edn空间不足,执行 young gc")]),a._v(" "),v("p",[a._v("b.old空间不足，perm空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc")])])}),[],!1,null,null,null);t.default=_.exports}}]);