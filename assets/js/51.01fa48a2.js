(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{394:function(t,e,r){"use strict";r.r(e);var n=r(42),p=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("ConcurrentHashMap不能排序，容器类中可以排序的Map和Set是TreeMap和TreeSet，但它们不是线程安全的。Java并发包中与TreeMap/TreeSet对应的并发版本是ConcurrentSkipListMap和ConcurrentSkipListSet\n")]),t._v(" "),r("h1",{attrs:{id:"基本概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),r("p",[t._v("我们知道，TreeSet是基于TreeMap实现的，与此类似，ConcurrentSkipListSet也是基于ConcurrentSkipListMap实现的，所以，我们主要来探讨ConcurrentSkipListMap。")]),t._v(" "),r("p",[t._v("ConcurrentSkipListMap是基于SkipList实现的，SkipList称为跳跃表或跳表，是一种数据结构，待会我们会进一步介绍。并发版本为什么采用跳表而不是树呢？原因也很简单，因为跳表更易于实现高效并发算法。")]),t._v(" "),r("p",[t._v("ConcurrentSkipListMap有如下特点：")]),t._v(" "),r("ul",[r("li",[t._v("没有使用锁，所有操作都是无阻塞的，所有操作都可以并行，包括写，多个线程可以同时写。")]),t._v(" "),r("li",[t._v("与ConcurrentHashMap类似，迭代器不会抛出ConcurrentModificationException，是弱一致的，迭代可能反映最新修改也可能不反映，一些方法如putAll, clear不是原子的。")]),t._v(" "),r("li",[t._v("与ConcurrentHashMap类似，同样实现了ConcurrentMap接口，直接支持一些原子复合操作。")]),t._v(" "),r("li",[t._v("与TreeMap一样，可排序，默认按键自然有序，可以传递比较器自定义排序，实现了SortedMap和NavigableMap接口。")])]),t._v(" "),r("p",[t._v("需要说明一下的是它的size方法，与大多数容器实现不同，这个方法不是常量操作，它需要遍历所有元素，复杂度为O(N)，而且遍历结束后，元素个数可能已经变了，一般而言，在并发应用中，这个方法用处不大。")]),t._v(" "),r("h1",{attrs:{id:"基本原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本原理"}},[t._v("#")]),t._v(" 基本原理")]),t._v(" "),r("p",[t._v("我们先来介绍下跳表的结构，跳表是基于链表的，在链表的基础上加了多层索引结构。我们通过一个简单的例子来看下，假定容器中包含如下元素：")]),t._v(" "),r("p",[t._v("3, 6, 7, 9, 12, 17, 19, 21, 25, 26")]),t._v(" "),r("p",[t._v("对Map来说，这些值可以视为键。ConcurrentSkipListMap会构造类似下图所示的跳表结构：\n"),r("img",{attrs:{src:"/images/ref/%E8%B7%B3%E8%A1%A801.png",alt:"Alt text"}})]),t._v(" "),r("p",[t._v("最下面一层，就是最基本的单向链表，这个链表是有序的。虽然是有序的，但我们知道，与数组不同，链表不能根据索引直接定位，不能进行二分查找。")]),t._v(" "),r("p",[t._v("为了快速查找，跳表有多层索引结构，这个例子中有两层，第一层有5个节点，第二层有2个节点。高层的索引节点一定同时是低层的索引节点，比如9和21。")]),t._v(" "),r("p",[t._v("高层的索引节点少，低层的多，统计概率上，第一层索引节点是实际元素数的1/2，第二层是第一层的1/2，逐层减半，但这不是绝对的，有随机性，只是大概如此。")]),t._v(" "),r("p",[t._v("对于每个索引节点，有两个指针，一个向右，指向下一个同层的索引节点，另一个向下，指向下一层的索引节点或基本链表节点。")]),t._v(" "),r("p",[t._v("有了这个结构，就可以实现类似二分查找了，查找元素总是从最高层开始，将待查值与下一个索引节点的值进行比较，如果大于索引节点，就向右移动，继续比较，如果小于，则向下移动到下一层进行比较。")]),t._v(" "),r("p",[t._v("下图两条线展示了查找值19和8的过程：\n"),r("img",{attrs:{src:"/images/ref/%E8%B7%B3%E8%A1%A802.png",alt:"Alt text"}})]),t._v(" "),r("p",[t._v("对于19，查找过程是：\n1.与9相比，大于9\n2.向右与21相比，小于21\n3.向下与17相比，大于17\n4.向右与21相比，小于21\n5.向下与19相比，找到")]),t._v(" "),r("p",[t._v("对于8，查找过程是：\n1.与9相比，小于9\n2.向下与6相比，大于6\n3.向右与9相比，小于9\n4.向下与7相比，大于7\n5.向右与9相比，小于9，不能再向下，没找到")]),t._v(" "),r("p",[t._v("这个结构是有序的，查找的性能与二叉树类似，复杂度是O(log(N))，不过，这个结构是如何构建起来的呢？")]),t._v(" "),r("p",[t._v("与二叉树类似，这个结构是在更新过程中进行保持的，保存元素的基本思路是：\n1.先保存到基本链表，找到待插入的位置，找到位置后，先插入基本链表\n2.更新索引层。")]),t._v(" "),r("p",[t._v("对于索引更新，随机计算一个数，表示为该元素最高建几层索引，一层的概率为1/2，二层为1/4，三层为1/8，依次类推。然后从最高层到最低层，在每一层，为该元素建立索引节点，建的过程也是先查找位置，再插入。")]),t._v(" "),r("p",[t._v("对于删除元素，ConcurrentSkipListMap不是一下子真的进行删除，为了避免并发冲突，有一个复杂的标记过程，在内部遍历元素的过程中会真正删除。")]),t._v(" "),r("p",[t._v("以上我们只是介绍了基本思路，为了实现并发安全、高效、无锁非阻塞，ConcurrentSkipListMap的实现非常复杂，具体我们就不探讨了，感兴趣的读者可以参考其源码，其中提到了多篇学术论文，论文中描述了它参考的一些算法。")]),t._v(" "),r("h1",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),r("ul",[r("li",[t._v("基于跳表(SkipList)实现。")]),t._v(" "),r("li",[t._v("跳表(SkipList)可以用来替代红黑树，使用概率均衡技术，插入、删除操作更简单、更快。")]),t._v(" "),r("li",[t._v("跳表(SkipList)本质上是以空间换取时间。")]),t._v(" "),r("li",[t._v("ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的。")]),t._v(" "),r("li",[t._v("ConcurrentSkipListMap中的元素是key-value键值对，而ConcurrentSkipListSet只用到了前者中的key。")])])])}),[],!1,null,null,null);e.default=p.exports}}]);